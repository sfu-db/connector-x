initSidebarItems({"constant":[["FILE_IDENTIFIER_LENGTH",""],["FLATBUFFERS_MAX_BUFFER_SIZE",""],["SIZE_F32",""],["SIZE_F64",""],["SIZE_I16",""],["SIZE_I32",""],["SIZE_I64",""],["SIZE_I8",""],["SIZE_SIZEPREFIX",""],["SIZE_SOFFSET",""],["SIZE_U16",""],["SIZE_U32",""],["SIZE_U64",""],["SIZE_U8",""],["SIZE_UOFFSET",""],["SIZE_VOFFSET",""],["VTABLE_METADATA_FIELDS",""]],"enum":[["ErrorTraceDetail","Traces the location of data errors. Not populated for Dos detecting errors. Useful for MissingRequiredField and Utf8Error in particular, though the other errors should not be producible by correct flatbuffers implementations."],["InvalidFlatbuffer","Describes how a flatuffer is invalid and, for data errors, roughly where. No extra tracing information is given for DoS detecting errors since it will probably be a lot."]],"fn":[["buffer_has_identifier",""],["byte_swap_f32","Swaps the bytes of an f32."],["byte_swap_f64","Swaps the bytes of an f64."],["emplace_scalar","Place an EndianScalar into the provided mutable byte slice. Performs endian conversion, if necessary."],["field_index_to_field_offset",""],["follow_cast_ref",""],["read_scalar","Read an EndianScalar from the provided byte slice. Performs endian conversion, if necessary."],["read_scalar_at","Read an EndianScalar from the provided byte slice at the specified location. Performs endian conversion, if necessary."],["root","Gets the root of the Flatbuffer, verifying it first with default options. Note that verification is an experimental feature and may not be maximally performant or catch every error (though that is the goal). See the `_unchecked` variants for previous behavior."],["root_unchecked","Gets root for a trusted Flatbuffer."],["root_with_opts","Gets the root of the Flatbuffer, verifying it first with given options. Note that verification is an experimental feature and may not be maximally performant or catch every error (though that is the goal). See the `_unchecked` variants for previous behavior."],["size_prefixed_root","Gets the root of a size prefixed Flatbuffer, verifying it first with default options. Note that verification is an experimental feature and may not be maximally performant or catch every error (though that is the goal). See the `_unchecked` variants for previous behavior."],["size_prefixed_root_unchecked","Gets root for a trusted, size prefixed, Flatbuffer."],["size_prefixed_root_with_opts","Gets the root of a size prefixed Flatbuffer, verifying it first with given options. Note that verification is an experimental feature and may not be maximally performant or catch every error (though that is the goal). See the `_unchecked` variants for previous behavior."]],"struct":[["BackwardsSOffset","ForwardsSOffset is used by Follow to traverse a FlatBuffer: the pointer is incremented by the negative of the value contained in this type."],["FileIdentifier","FileIdentifier is used by Follow to traverse a FlatBuffer: the pointer is dereferenced into a byte slice, whose bytes are the file identifer value."],["FlatBufferBuilder","FlatBufferBuilder builds a FlatBuffer through manipulating its internal state. It has an owned `Vec<u8>` that grows as needed (up to the hardcoded limit of 2GiB, which is set by the FlatBuffers format)."],["FollowStart","FollowStart wraps a Follow impl in a struct type. This can make certain programming patterns more ergonomic."],["ForwardsUOffset","ForwardsUOffset is used by Follow to traverse a FlatBuffer: the pointer is incremented by the value contained in this type."],["ForwardsVOffset","ForwardsVOffset is used by Follow to traverse a FlatBuffer: the pointer is incremented by the value contained in this type."],["SkipFileIdentifier","SkipFileIdentifier is used by Follow to traverse a FlatBuffer: the pointer is incremented by a fixed constant in order to skip over the file identifier value."],["SkipRootOffset","SkipRootOffset is used by Follow to traverse a FlatBuffer: the pointer is incremented by a fixed constant in order to skip over the root offset value."],["SkipSizePrefix","SkipSizePrefix is used by Follow to traverse a FlatBuffer: the pointer is incremented by a fixed constant in order to skip over the size prefix value."],["Table",""],["TableFinishedWIPOffset","TableFinishedWIPOffset marks a WIPOffset as being for a finished table."],["TableUnfinishedWIPOffset","TableUnfinishedWIPOffset marks a WIPOffset as being for an unfinished table."],["UnionWIPOffset","UnionWIPOffset marks a WIPOffset as being for a union value."],["VTableWIPOffset","VTableWIPOffset marks a WIPOffset as being for a vtable."],["Vector",""],["VectorIter","An iterator over a `Vector`."],["Verifier","Carries the verification state. Should not be reused between tables."],["VerifierOptions",""],["WIPOffset","WIPOffset contains an UOffsetT with a special meaning: it is the location of data relative to the end of an in-progress FlatBuffer. The FlatBufferBuilder uses this to track the location of objects in an absolute way. The impl of Push converts a WIPOffset into a ForwardsUOffset."]],"trait":[["EndianScalar","Trait for values that must be stored in little-endian byte order, but might be represented in memory as big-endian. Every type that implements EndianScalar is a valid FlatBuffers scalar value."],["Follow","Follow is a trait that allows us to access FlatBuffers in a declarative, type safe, and fast way. They compile down to almost no code (after optimizations). Conceptually, Follow lifts the offset-based access patterns of FlatBuffers data into the type system. This trait is used pervasively at read time, to access tables, vtables, vectors, strings, and all other data. At this time, Follow is not utilized much on the write path."],["Push","Trait to abstract over functionality needed to write values (either owned or referenced). Used in FlatBufferBuilder and implemented for generated types."],["SafeSliceAccess",""],["SimpleToVerifyInSlice",""],["Verifiable",""]],"type":[["SOffsetT","SOffsetT is a relative pointer from tables to their vtables."],["UOffsetT","UOffsetT is used represent both for relative pointers and lengths of vectors."],["VOffsetT","VOffsetT is a relative pointer in vtables to point from tables to field data."]]});