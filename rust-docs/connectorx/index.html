<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="ConnectorX"><title>connectorx - Rust</title><script> if (window.location.protocol !== "file:") document.write(`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2">`)</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-e935ef01ae1c1829.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="connectorx" data-themes="" data-resource-suffix="" data-rustdoc-version="1.78.0 (9b00956e5 2024-04-29)" data-channel="1.78.0" data-search-js="search-42d8da7a6b9792c2.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-4c98445ec4002617.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-12cf3b4f4f9dc36d.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../connectorx/index.html">connectorx</a><span class="version">0.3.3-alpha.2</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li></ul></section></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../connectorx/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">connectorx</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/connectorx/lib.rs.html#1-220">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="connectorx"><a class="doc-anchor" href="#connectorx">§</a>ConnectorX</h2>
<p>ConnectorX enables you to load data from databases into dataframes in the fastest and most memory efficient way by leveraging
zero-copy and partition-based parallelism.</p>
<p>Currently, ConnectorX consists of a Rust core library and a python library. This is the documentation for the Rust crate.
For the documentation of the Python library, please refer to our <a href="https://github.com/sfu-db/connector-x">Github Readme</a>.</p>
<h2 id="design"><a class="doc-anchor" href="#design">§</a>Design</h2>
<p>A data loading problem consists of three sub-problems:</p>
<ol>
<li>How to connect to the data source and read data.</li>
<li>How to connect to the data destination and write data.</li>
<li>How to map the types between the source and destination.</li>
</ol>
<p>Additionally, since ConnectorX will partition a query into partitions and execute them in parallel, we also have
4. How to partition the query and run them in parallel.</p>
<p>ConnectorX approaches these problems by defining abstractions on sources, destinations, and mapping rules.
For the partition-based parallelism, ConnectorX will partition the query as well as the source and the destination
together and put them into threads.
Each thread will own exactly 1 query, 1 partitioned source, and 1 partitioned destination.</p>
<p>The following graph depicts the internal mechanism when ConnectorX is downloading the data.</p>
<div class="example-wrap"><pre class="language-text"><code>                    +------------------------------------------------------------+
                    |                           Thread 1                         |
                    |                                                            |
    +---+           | +-----------------+   +-------------+  +-----------------+ |          +---+
    |   +-----------+&gt;| Partitioned Src +--&gt;| Type Mapper +-&gt;| Partitioned Dst +-+---------&gt;|   |
    |   |           | +-----------------+   +-------------+  +-----------------+ |          |   |
    | D |           |                                                            |          | D |
    | a |           +------------------------------------------------------------+          | a |
    | t |                                          .                                        | t |
    | a |                                          .                                        | a |
    | b |                                          .                                        | f |
    | a |           +------------------------------------------------------------+          | r |
    | s |           |                           Thread n                         |          | a |
    | e |           |                                                            |          | m |
    |   |           | +-----------------+   +-------------+  +-----------------+ |          | e |
    |   +-----------+&gt;| Partitioned Src +--&gt;| Type Mapper +-&gt;| Partitioned Dst +-+---------&gt;|   |
    +---+           | +-----------------+   +-------------+  +-----------------+ |          +---+
                    |                                                            |
                    +------------------------------------------------------------+

</code></pre></div><h3 id="how-does-connectorx-download-the-data"><a class="doc-anchor" href="#how-does-connectorx-download-the-data">§</a>How does ConnectorX download the data?</h3>
<p>Upon receiving the query, e.g. SELECT * FROM lineitem, ConnectorX will first issue a LIMIT 1 query SELECT * FROM lineitem LIMIT 1 to get the schema of the result set.</p>
<p>Then, if partition_on is specified, ConnectorX will issue <code>SELECT MIN($partition_on), MAX($partition_on) FROM (SELECT * FROM lineitem)</code> to know the range of the partition column.
After that, the original query is split into partitions based on the min/max information, e.g. <code>SELECT * FROM (SELECT * FROM lineitem) WHERE $partition_on &gt; 0 AND $partition_on &lt; 10000</code>.
ConnectorX will then run a count query to get the partition size (e.g. <code>SELECT COUNT(*) FROM (SELECT * FROM lineitem) WHERE $partition_on &gt; 0 AND $partition_on &lt; 10000</code>).
If the partition is not specified, the count query will be <code>SELECT COUNT(*) FROM (SELECT * FROM lineitem)</code>.</p>
<p>Finally, ConnectorX will use the schema info as well as the count info to allocate memory and download data by executing the queries normally.
Once the downloading begins, there will be one thread for each partition so that the data are downloaded in parallel at the partition level.
The thread will issue the query of the corresponding partition to the database and then write the returned data to the destination row-wise or column-wise (depends on the database) in a streaming fashion.
This mechanism implies that having an index on the partition column is recommended to make full use of the parallel downloading power provided by ConnectorX.</p>
<h2 id="extending-connectorx"><a class="doc-anchor" href="#extending-connectorx">§</a>Extending ConnectorX</h2><h3 id="adding-a-new-source"><a class="doc-anchor" href="#adding-a-new-source">§</a>Adding a new source</h3>
<p>To add a new data source, you need to implement <a href="sources/trait.Source.html" title="trait connectorx::sources::Source"><code>sources::Source</code></a>, <a href="sources/trait.SourcePartition.html" title="trait connectorx::sources::SourcePartition"><code>sources::SourcePartition</code></a>, <a href="sources/trait.PartitionParser.html" title="trait connectorx::sources::PartitionParser"><code>sources::PartitionParser</code></a>, and <a href="sources/trait.Produce.html" title="trait connectorx::sources::Produce"><code>sources::Produce</code></a> for the source.
In detail, <a href="sources/trait.Source.html" title="trait connectorx::sources::Source"><code>sources::Source</code></a> describes how to connect to the database from a connection string, as well as how to do partitioning on the source to produce a list of <a href="sources/trait.SourcePartition.html" title="trait connectorx::sources::SourcePartition"><code>sources::SourcePartition</code></a>.
<a href="sources/trait.SourcePartition.html" title="trait connectorx::sources::SourcePartition"><code>sources::SourcePartition</code></a> describes how to get the row count for the specific partition so that the destination can preallocate the memory.
Finally, <a href="sources/trait.PartitionParser.html" title="trait connectorx::sources::PartitionParser"><code>sources::PartitionParser</code></a> and <a href="sources/trait.Produce.html" title="trait connectorx::sources::Produce"><code>sources::Produce</code></a> abstracts away the detail about how does each partition parse different types.</p>
<h3 id="adding-a-new-destination"><a class="doc-anchor" href="#adding-a-new-destination">§</a>Adding a new destination</h3>
<p>To add a new data destination, you need to implement <a href="destinations/trait.Destination.html" title="trait connectorx::destinations::Destination"><code>destinations::Destination</code></a>, <a href="destinations/trait.DestinationPartition.html" title="trait connectorx::destinations::DestinationPartition"><code>destinations::DestinationPartition</code></a>, and <a href="destinations/trait.Consume.html" title="trait connectorx::destinations::Consume"><code>destinations::Consume</code></a>. Similar to the sources,
<a href="destinations/trait.Destination.html" title="trait connectorx::destinations::Destination"><code>destinations::Destination</code></a> describes how to allocate the memory of the data destination, as well as how to do partitioning on the destination to produce a list of <a href="destinations/trait.DestinationPartition.html" title="trait connectorx::destinations::DestinationPartition"><code>destinations::DestinationPartition</code></a>.
<a href="destinations/trait.DestinationPartition.html" title="trait connectorx::destinations::DestinationPartition"><code>destinations::DestinationPartition</code></a> and <a href="destinations/trait.Consume.html" title="trait connectorx::destinations::Consume"><code>destinations::Consume</code></a> abstract away the detail about how does each partition writes different types.</p>
<h3 id="adding-a-new-transport-type-mapping"><a class="doc-anchor" href="#adding-a-new-transport-type-mapping">§</a>Adding a new transport (type mapping)</h3>
<p>After having a source and a destination that describes how to read and write the data,
ConnectorX also needs to know how to convert the values with different types from the source to the destination.
For example, Postgres can produce a <code>uuid</code> type but there’s no uuid in Arrow. It is the transport’s duty to convert
the <code>uuid</code> into an Arrow compatible type, e.g. string. You can use the <a href="macro.impl_transport.html" title="macro connectorx::impl_transport"><code>impl_transport!</code></a> macro to define a transport.</p>
<h3 id="putting-things-together"><a class="doc-anchor" href="#putting-things-together">§</a>Putting things together</h3>
<p>Say, you decide to load data from SQL Server to Arrow. In ConnectorX we already provided the source for SQL Server as <a href="sources/sqlite/struct.SQLiteSource.html" title="struct connectorx::sources::sqlite::SQLiteSource"><code>sources::sqlite::SQLiteSource</code></a>, and the
Arrow destination <a href="destinations/arrow/struct.ArrowDestination.html" title="struct connectorx::destinations::arrow::ArrowDestination"><code>destinations::arrow::ArrowDestination</code></a>, as well as the transport <a href="transports/struct.SQLiteArrowTransport.html" title="struct connectorx::transports::SQLiteArrowTransport"><code>transports::SQLiteArrowTransport</code></a>.
Given the source, destination and transport already implemented, you can use <a href="prelude/struct.Dispatcher.html" title="struct connectorx::prelude::Dispatcher"><code>dispatcher::Dispatcher</code></a> to load the data:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>connectorx::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>destination = ArrowDestination::new();
<span class="kw">let </span>source = SQLiteSource::new(<span class="string">"/path/to/db"</span>, <span class="number">10</span>).expect(<span class="string">"cannot create the source"</span>);
<span class="kw">let </span>queries = <span class="kw-2">&amp;</span>[<span class="string">"SELECT * FROM db WHERE id &lt; 100"</span>, <span class="string">"SELECT * FROM db WHERE id &gt;= 100"</span>];
<span class="kw">let </span>dispatcher = Dispatcher::&lt;SQLiteSource, ArrowDestination, SQLiteArrowTransport&gt;::new(source, <span class="kw-2">&amp;mut </span>destination, queries, <span class="prelude-val">None</span>);
dispatcher.run().expect(<span class="string">"run failed"</span>);

<span class="kw">let </span>data = destination.arrow();</code></pre></div>
<p>Or simply you can directly use the <a href="get_arrow/fn.get_arrow.html" title="fn connectorx::get_arrow::get_arrow"><code>get_arrow::get_arrow</code></a> or <a href="get_arrow2/fn.get_arrow2.html" title="fn connectorx::get_arrow2::get_arrow2"><code>get_arrow2::get_arrow2</code></a> in which we wrapped the above procedures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>connectorx::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::convert::TryFrom;

<span class="kw">let </span><span class="kw-2">mut </span>source_conn = SourceConn::try_from(<span class="string">"postgresql://username:password@host:port/db?cxprotocol=binary"</span>).expect(<span class="string">"parse conn str failed"</span>);
<span class="kw">let </span>queries = <span class="kw-2">&amp;</span>[CXQuery::from(<span class="string">"SELECT * FROM table WHERE id &lt; 100"</span>), CXQuery::from(<span class="string">"SELECT * FROM table WHERE id &gt;= 100"</span>)];
<span class="kw">let </span>destination = get_arrow(<span class="kw-2">&amp;</span>source_conn, <span class="prelude-val">None</span>, queries).expect(<span class="string">"run failed"</span>);

<span class="kw">let </span>data = destination.arrow();</code></pre></div>
<p>NOTE: the pool size parameter <code>nconn</code> used in initializing the source should be larger than or equal to the number of partitioned queries input later.</p>
<h3 id="need-more-examples"><a class="doc-anchor" href="#need-more-examples">§</a>Need more examples?</h3>
<p>You can use the existing implementation as the example.
<a href="https://github.com/sfu-db/connector-x/tree/main/connectorx/src/sources/mysql">MySQL source</a>,
<a href="https://github.com/sfu-db/connector-x/tree/main/connectorx/src/destinations/arrow">Arrow destination</a>,
<a href="https://github.com/sfu-db/connector-x/blob/main/connectorx/src/transports/mysql_arrow.rs">MySQL to Arrow transport</a>.</p>
<h2 id="sources-protocols--destinations-that-is-implemented-in-the-rust-core"><a class="doc-anchor" href="#sources-protocols--destinations-that-is-implemented-in-the-rust-core">§</a>Sources protocols &amp; Destinations that is implemented in the Rust core.</h2><h3 id="sources"><a class="doc-anchor" href="#sources">§</a>Sources</h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Postgres</li>
<li><input disabled="" type="checkbox" checked=""/>
Mysql</li>
<li><input disabled="" type="checkbox" checked=""/>
Sqlite</li>
<li><input disabled="" type="checkbox" checked=""/>
SQL Server</li>
<li><input disabled="" type="checkbox" checked=""/>
Oracle</li>
<li><input disabled="" type="checkbox" checked=""/>
BigQuery</li>
</ul>
<h3 id="destinations"><a class="doc-anchor" href="#destinations">§</a>Destinations</h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Arrow</li>
<li><input disabled="" type="checkbox" checked=""/>
Arrow2</li>
</ul>
<h2 id="feature-gates"><a class="doc-anchor" href="#feature-gates">§</a>Feature gates</h2>
<p>By default, ConnectorX does not enable any sources / destinations to keep the dependencies minimal.
Instead, we provide following features for you to opt-in: <code>src_sqlite</code>, <code>src_postgres</code>, <code>src_mysql</code>, <code>src_mssql</code>, <code>src_oracle</code>, <code>dst_arrow</code>, <code>dst_arrow2</code>.
For example, if you’d like to load data from Postgres to Arrow, you can enable <code>src_postgres</code> and <code>dst_arrow</code> in <code>Cargo.toml</code>.
This will enable <a href="sources/postgres/index.html" title="mod connectorx::sources::postgres"><code>sources::postgres</code></a>, <a href="destinations/arrow/index.html" title="mod connectorx::destinations::arrow"><code>destinations::arrow</code></a> and <a href="transports/struct.PostgresArrowTransport.html" title="struct connectorx::transports::PostgresArrowTransport"><code>transports::PostgresArrowTransport</code></a>.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="arrow_batch_iter/index.html" title="mod connectorx::arrow_batch_iter">arrow_batch_iter</a></div></li><li><div class="item-name"><a class="mod" href="constants/index.html" title="mod connectorx::constants">constants</a></div></li><li><div class="item-name"><a class="mod" href="data_order/index.html" title="mod connectorx::data_order">data_order</a></div><div class="desc docblock-short">This module provides two data orders: row-wise and column-wise for tabular data,
as well as a function to coordinate the data order between source and destination.</div></li><li><div class="item-name"><a class="mod" href="destinations/index.html" title="mod connectorx::destinations">destinations</a></div><div class="desc docblock-short">This module defines three traits <a href="destinations/trait.Destination.html" title="trait connectorx::destinations::Destination"><code>Destination</code></a>, <a href="destinations/trait.DestinationPartition.html" title="trait connectorx::destinations::DestinationPartition"><code>DestinationPartition</code></a>, and <a href="destinations/trait.Consume.html" title="trait connectorx::destinations::Consume"><code>Consume</code></a> to define a destination.
This module also contains destination implementations for various dataframes.</div></li><li><div class="item-name"><a class="mod" href="errors/index.html" title="mod connectorx::errors">errors</a></div></li><li><div class="item-name"><a class="mod" href="fed_dispatcher/index.html" title="mod connectorx::fed_dispatcher">fed_dispatcher</a></div></li><li><div class="item-name"><a class="mod" href="fed_rewriter/index.html" title="mod connectorx::fed_rewriter">fed_rewriter</a></div></li><li><div class="item-name"><a class="mod" href="get_arrow/index.html" title="mod connectorx::get_arrow">get_arrow</a></div></li><li><div class="item-name"><a class="mod" href="get_arrow2/index.html" title="mod connectorx::get_arrow2">get_arrow2</a></div></li><li><div class="item-name"><a class="mod" href="partition/index.html" title="mod connectorx::partition">partition</a></div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod connectorx::prelude">prelude</a></div></li><li><div class="item-name"><a class="mod" href="source_router/index.html" title="mod connectorx::source_router">source_router</a></div></li><li><div class="item-name"><a class="mod" href="sources/index.html" title="mod connectorx::sources">sources</a></div><div class="desc docblock-short">This module defines four traits <a href="sources/trait.Source.html" title="trait connectorx::sources::Source"><code>Source</code></a>, <a href="sources/trait.SourcePartition.html" title="trait connectorx::sources::SourcePartition"><code>SourcePartition</code></a>, <a href="sources/trait.PartitionParser.html" title="trait connectorx::sources::PartitionParser"><code>PartitionParser</code></a>, and <a href="sources/trait.Produce.html" title="trait connectorx::sources::Produce"><code>Produce</code></a>  to define a source.
This module also contains source implementations for various databases.</div></li><li><div class="item-name"><a class="mod" href="transports/index.html" title="mod connectorx::transports">transports</a></div><div class="desc docblock-short">This module contains transport definitions for the sources and destinations implemented in ConnectorX.</div></li><li><div class="item-name"><a class="mod" href="typesystem/index.html" title="mod connectorx::typesystem">typesystem</a></div><div class="desc docblock-short">This module defines traits that required to define a typesystem.</div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.impl_transport.html" title="macro connectorx::impl_transport">impl_transport</a></div><div class="desc docblock-short">A macro to help define a Transport.</div></li><li><div class="item-name"><a class="macro" href="macro.impl_typesystem.html" title="macro connectorx::impl_typesystem">impl_typesystem</a></div><div class="desc docblock-short">Associate physical representations to a typesystem.</div></li></ul></section></div></main></body></html>