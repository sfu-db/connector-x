initSidebarItems({"constant":[["ENUM_MAX_DATE_UNIT",""],["ENUM_MAX_DICTIONARY_KIND",""],["ENUM_MAX_ENDIANNESS",""],["ENUM_MAX_FEATURE",""],["ENUM_MAX_INTERVAL_UNIT",""],["ENUM_MAX_METADATA_VERSION",""],["ENUM_MAX_PRECISION",""],["ENUM_MAX_TIME_UNIT",""],["ENUM_MAX_TYPE",""],["ENUM_MAX_UNION_MODE",""],["ENUM_MIN_DATE_UNIT",""],["ENUM_MIN_DICTIONARY_KIND",""],["ENUM_MIN_ENDIANNESS",""],["ENUM_MIN_FEATURE",""],["ENUM_MIN_INTERVAL_UNIT",""],["ENUM_MIN_METADATA_VERSION",""],["ENUM_MIN_PRECISION",""],["ENUM_MIN_TIME_UNIT",""],["ENUM_MIN_TYPE",""],["ENUM_MIN_UNION_MODE",""],["ENUM_VALUES_DATE_UNIT",""],["ENUM_VALUES_DICTIONARY_KIND",""],["ENUM_VALUES_ENDIANNESS",""],["ENUM_VALUES_FEATURE",""],["ENUM_VALUES_INTERVAL_UNIT",""],["ENUM_VALUES_METADATA_VERSION",""],["ENUM_VALUES_PRECISION",""],["ENUM_VALUES_TIME_UNIT",""],["ENUM_VALUES_TYPE",""],["ENUM_VALUES_UNION_MODE",""]],"enum":[["BinaryOffset",""],["BoolOffset",""],["DateOffset",""],["DecimalOffset",""],["DictionaryEncodingOffset",""],["DurationOffset",""],["FieldOffset",""],["FixedSizeBinaryOffset",""],["FixedSizeListOffset",""],["FloatingPointOffset",""],["IntOffset",""],["IntervalOffset",""],["KeyValueOffset",""],["LargeBinaryOffset",""],["LargeListOffset",""],["LargeUtf8Offset",""],["ListOffset",""],["MapOffset",""],["NullOffset",""],["SchemaOffset",""],["Struct_Offset",""],["TimeOffset",""],["TimestampOffset",""],["UnionOffset",""],["Utf8Offset",""]],"fn":[["finish_schema_buffer",""],["finish_size_prefixed_schema_buffer",""],["get_root_as_schema",""],["get_size_prefixed_root_as_schema",""],["root_as_schema","Verifies that a buffer of bytes contains a `Schema` and returns it. Note that verification is still experimental and may not catch every error, or be maximally performant. For the previous, unchecked, behavior use `root_as_schema_unchecked`."],["root_as_schema_unchecked","Assumes, without verification, that a buffer of bytes contains a Schema and returns it."],["root_as_schema_with_opts","Verifies, with the given options, that a buffer of bytes contains a `Schema` and returns it. Note that verification is still experimental and may not catch every error, or be maximally performant. For the previous, unchecked, behavior use `root_as_schema_unchecked`."],["size_prefixed_root_as_schema","Verifies that a buffer of bytes contains a size prefixed `Schema` and returns it. Note that verification is still experimental and may not catch every error, or be maximally performant. For the previous, unchecked, behavior use `size_prefixed_root_as_schema_unchecked`."],["size_prefixed_root_as_schema_unchecked","Assumes, without verification, that a buffer of bytes contains a size prefixed Schema and returns it."],["size_prefixed_root_as_schema_with_opts","Verifies, with the given verifier options, that a buffer of bytes contains a size prefixed `Schema` and returns it. Note that verification is still experimental and may not catch every error, or be maximally performant. For the previous, unchecked, behavior use `root_as_schema_unchecked`."]],"struct":[["Binary","Opaque binary data"],["BinaryArgs",""],["BinaryBuilder",""],["Bool",""],["BoolArgs",""],["BoolBuilder",""],["Buffer","A Buffer represents a single contiguous memory segment"],["Date","Date is either a 32-bit or 64-bit type representing elapsed time since UNIX epoch (1970-01-01), stored in either of two units:"],["DateArgs",""],["DateBuilder",""],["DateUnit",""],["Decimal","Exact decimal value represented as an integer value in two's complement. Currently only 128-bit (16-byte) and 256-bit (32-byte) integers are used. The representation uses the endianness indicated in the Schema."],["DecimalArgs",""],["DecimalBuilder",""],["DictionaryEncoding",""],["DictionaryEncodingArgs",""],["DictionaryEncodingBuilder",""],["DictionaryKind","Dictionary encoding metadata Maintained for forwards compatibility, in the future Dictionaries might be explicit maps between integers and values allowing for non-contiguous index values"],["Duration",""],["DurationArgs",""],["DurationBuilder",""],["Endianness","Endianness of the platform producing the data"],["Feature","Represents Arrow Features that might not have full support within implementations. This is intended to be used in two scenarios:"],["Field","A field represents a named column in a record / row batch or child of a nested type."],["FieldArgs",""],["FieldBuilder",""],["FixedSizeBinary",""],["FixedSizeBinaryArgs",""],["FixedSizeBinaryBuilder",""],["FixedSizeList",""],["FixedSizeListArgs",""],["FixedSizeListBuilder",""],["FloatingPoint",""],["FloatingPointArgs",""],["FloatingPointBuilder",""],["Int",""],["IntArgs",""],["IntBuilder",""],["Interval",""],["IntervalArgs",""],["IntervalBuilder",""],["IntervalUnit",""],["KeyValue","user defined key value pairs to add custom metadata to arrow key namespacing is the responsibility of the user"],["KeyValueArgs",""],["KeyValueBuilder",""],["LargeBinary","Same as Binary, but with 64-bit offsets, allowing to represent extremely large data values."],["LargeBinaryArgs",""],["LargeBinaryBuilder",""],["LargeList","Same as List, but with 64-bit offsets, allowing to represent extremely large data values."],["LargeListArgs",""],["LargeListBuilder",""],["LargeUtf8","Same as Utf8, but with 64-bit offsets, allowing to represent extremely large data values."],["LargeUtf8Args",""],["LargeUtf8Builder",""],["List",""],["ListArgs",""],["ListBuilder",""],["Map","A Map is a logical nested type that is represented as"],["MapArgs",""],["MapBuilder",""],["MetadataVersion",""],["Null","These are stored in the flatbuffer in the Type union below"],["NullArgs",""],["NullBuilder",""],["Precision",""],["Schema","A Schema describes the columns in a row batch"],["SchemaArgs",""],["SchemaBuilder",""],["Struct_","A Struct_ in the flatbuffer metadata is the same as an Arrow Struct (according to the physical memory layout). We used Struct_ here as Struct is a reserved word in Flatbuffers"],["Struct_Args",""],["Struct_Builder",""],["Time","Time type. The physical storage type depends on the unit"],["TimeArgs",""],["TimeBuilder",""],["TimeUnit",""],["Timestamp","Time elapsed from the Unix epoch, 00:00:00.000 on 1 January 1970, excluding leap seconds, as a 64-bit integer. Note that UNIX time does not include leap seconds."],["TimestampArgs",""],["TimestampBuilder",""],["Type","Top-level Type value, enabling extensible type-specific metadata. We can add new logical types to Type without breaking backwards compatibility"],["TypeUnionTableOffset",""],["Union","A union is a complex type with children in Field By default ids in the type vector refer to the offsets in the children optionally typeIds provides an indirection between the child offset and the type id for each child `typeIds[offset]` is the id used in the type vector"],["UnionArgs",""],["UnionBuilder",""],["UnionMode",""],["Utf8","Unicode with UTF-8 encoding"],["Utf8Args",""],["Utf8Builder",""]]});